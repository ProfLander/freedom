#:TITLE TODO

- [x] Tighter control over async executor scheduling
  - Currently runs 200 iterations per `yield_now`
  - Means winit will be starved of CPU time
  - Not affected by task spawning strategy
  - Appears hardcoded
  - FIXED: Used an atomic bool + spawned future to guarantee each task gets one turn per sleep

- [x] Move script system into Scheme

- [x] Move plugin system into Scheme

- [ ] Finalize self-contained runtime
  - Logging should be initialized from Scheme as part of kernel startup
  - Each address space that lazily constructs an engine needs it to be fully-formed and ready to go
  - Ergo, each instance of the engine needs to start with a path to a kernel script,
    and run it at construction time to establish a baseline environment
  - Each instance will likely also want to run a specialized startup script, though this is case-by-case
    - Main runs `main.scm` by convention
    - Winit takes quoted syntax in its run method
    - Another plugin might want to extend the kernel environment, then run a preset (or provided) entrypoint

- [ ] Move FS watcher integration into a `freedom-notify` dylib
  - Can load from kernel after starting plugin system, setup plugin + script watching late

- [ ] Reintroduce threading
  - Spawn (1 * main) + (num_cpu * worker) threads from rust
  - Have each call `make-channels` and pass its sender to the main thread
    - Compose a shared bus from these senders
    - Propagate to all threads via channel as an initial sync-and-start
      - Prevents any comms / task spawning before everything is ready
    - Use for all inter-thread coordination
      - i.e. A thread can send a task + its sender to another thread in order to model a callback
  - Control from scheme
    - Handles to initial set of threads are stored in a pool
    - Can take from pool to assign a specialized task to a thread
    - Can spawn a task onto the remaining threads via specialized function
      - This should mark a thread as busy and prevent it from being taken for specialized use
      - When all are busy, tasks should either queue, or spawn onto threads in a round-robin fashion
        - Queueing introduces more overhead per op since threads have to sync and fetch a new task
        - Round-robin risks spawning a short task on a thread that's already processing a long one
          - That said, if we assume all pool tasks are properly async, this should not be a problem
    - Attempting to take from pool when only 1 thread remains should spawn a new one
      - Pool should always have at least 1 thread to maintain parallelism semantic

- [ ] Implement async stdio
  - Blocking prevents winit from functioning properly
  - [ ] Start with basic stdin / stdout pipes
    - Need the means to make this async on the scheme side
  - [ ] Add readline as a switchable mode
    - Preferably from scheme
      - Choose which script to respawn based on state

- [ ] Troubleshoot non-closing windows
  - May be an artifact of blocking the winit loop, or of scheme value capture

- [ ] Consider replacing scheme-level `script` abstraction with futures
  - Reduces definition load on freedom::async, since scripts could simply construct a future
    - Effectively equivalent, since they're spawned and run outside of scheme
  - Can likely apply similar logic to other value-spawning specializations, replace with future constructors

- [ ] Reimplement wgpu + egui demo
  - Each their own plugin
  - Load in winit address space
  - Expose functions to be called by winit
  - Neither should need to touch engine or executor
  - Can reuse implementations from freedom-v1

- [ ] `build.rs` machinery for shipping scheme files in crates
  - Preferably not as raw text
  - `RawProgramWithSymbols` likely no good, since it can't be shared across engines
    (i.e. Across build-time / runtime)
  - `Executable` maybe; need to search github repo for relevant conversations / PRs,
    as there was some discussion of serializable programs

- [ ] Filesystem plugin
  - Should run on its own thread
  - Provide storage for automatic loading as per scripts / plugins
  - Watch a directory of gamedata and update accordingly
  - Likely generalizable systems, scripts can be subsumed
    - But not plugins, as they must be loaded from the filesystem
  - Should be able to provide file lifecycle machinery
    - i.e. Means to process file types into corresponding data,
      add / update / delete on change at runtime, etc.
    - Probably best done by passing raw file data across plugin boundaries
      and allowing specialized types to be parsed and constructed in their own domains
  - Most of this should live in scheme, since plugins should be no more than bindings to it

- [ ] Egui debugging machinery
  - Scheme state
    - Modules, bindings, etc.
      - Can map SteelVal to widgets
        - Will need to consider multiple scheme engines
          - i.e. Per-thread, per-plugin
        - Hopefully use `make-channels` for propagating to egui
        - May need a command interface
        - Will need the means to specialize against certain forms / data types
          - i.e. Check a list of implementations, fallback to general-purpose if not found
  - Filesystem
    - Will only be able to show file data by default, since specialized types live in their local domains
    - Send widget definitions over the domain boundary to visualize specialized types like textures etc?

- [ ] Sound plugin
  - Use cpal

- [ ] Load Necrodome gamedata

- [ ] Collision / physics plugins
  - Can use parry and rapier